# Typescript Basic+

## Instalaci√≥n de Typescript

No vamos a instalar TypeScript de manera global, sino solo para el proyecto, ya que normalmente as√≠ se hace en mundo real. Se trabaja por proyecto.

## Realicemos los siguientes pasos:

Creamos una carpeta para nuestro proyecto (el nombre que desees) e ingresamos a la misma. Mediante la terminal ser√≠a lo siguiente:

- cmkdir ts-project
- cd tsc --version

Abrimos nuestro editor de c√≥digo desde la ubicaci√≥n de la carpeta del proyecto. Si usas Visual Studio Code, usando la terminal es as√≠:
code .

## Crearemos los siguientes archivos:

Un archivo .gitignore en el editor o desde la terminal. Para su contenido, podemos utilizar la p√°gina gitignore.io. En nuestro programa necesitaremos las siguientes especificaciones:

P√°gina de gitignore
Luego copiamos lo que nos genera la web y lo pegamos en nuestro gitignore desde nuestro editor de c√≥digo.

Un archivo .editorconfig (opcional), si est√°s usando Visual Studio Code, con el fin de dar una configuraci√≥n simple y sencilla a la hora de ejecutar c√≥digo. Aqu√≠ copia y pega lo siguiente:

# Editor configuration, see https://editorconfig.org

root = true

[*]
charset = utf-8
indent_style = space
indent_size = 2
insert_final_newline = true
trim_trailing_whitespace = true

[*.ts]
quote_type = single

[*.md]
max_line_length = off
trim_trailing_whitespace = false

## Para que funcione esta configuraci√≥n

debes tener instalado la siguiente extensi√≥n en tu Visual Studio Code: Extensi√≥n EditorConfig

Necistaremos tambi√©n tener creado una carpeta de nombre src dentro de nuestro proyecto
Ahora crearemos nuestro archivo package.json de manera simple desde la terminal y dentro de la ruta del proyecto:

    * npm init -y

As√≠ deber√≠a estar quedando conformado nuestro proyecto previo al √∫ltimo paso
Archivos de configuraci√≥n

Finalmente, instalemos TypeScript üòä. Desde la terminal y dentro de la ruta del proyecto, ejecuta:

    * npm install typescript --save-dev

## Para verificar la versi√≥n instalada:

- npx tsc --version

Nos ayuda a ahorrar mucho trabajo manual como transpilar archivo por archivo, indicar el target, etc.

## Creando un archivo TSConfig.json

En la terminal, ubic√°ndonos dentro del directorio en el que queremos que se cree el archivo, ejecutemos:

- npx tsc --init

Nos crear√° autom√°ticamente el archivo con propiedades b√°sicas activadas:
Resultado al correr el comando: npx tsc --init

Dentro del archivo TSConfig.json podemos ver que tiene muchas propiedades comentadas (desactivadas) y de las cuales solo algunas est√°n activadas.

## Compilaci√≥n en TypeScript

Nuestro c√≥digo TypeScript se transpilar√° seg√∫n las propiedades indicadas en nuestro archivo `TSConfig.json``:
33

- npx tsc

## Compilaci√≥n en tiempo real

Nos puede resultar tedioso estar ejecutando el comando anterior siempre despu√©s de escribir nuestro c√≥digo. Para evitar esto, podemos hacer que el compilador est√© detectando cada cambio que realicemos en nuestros archivos TypeScript y haga la transpilaci√≥n de inmediato:

- npx tsc --watch

## Proyecto

Creemos el archivo TSConfig.json en nuestro proyecto
Activamos las siguientes propiedades dentro de dicho archivo:
outDir: indicando la carpeta dist como el directorio destino de los archivos transpilados

- Ejemplo de outDir
- rootDir: indicamos que nuestros archivos TypeScript, los cuales ser√°n ‚Äúcompilados‚Äù luego, estar√°n en la carpeta src
  Ejemplo de rootDir

Creamos el archivo 02-demo2.ts dentro de la carpeta src con el siguiente c√≥digo:
const numbers = [1,3,4];

Probemos la compilaci√≥n de nuestros archivos:
npx tsc

## Estructura de archivos del proyecto de TypeScript

Observaremos que los archivos transpilados se encuentran en nuestra carpeta dist.

## Qu√© es el tipado en TypeScript

El tipado en TypeScript hace referencia a c√≥mo declaramos una variable, necesitamos asignar el tipo de dato, conocido como type annotation, con esto evitamos mezclar distintos tipos de datos.

## La flexibilidad de JavaScript

Nosotros podemos declarar una variable de un tipo de valor y a lo largo del c√≥digo ir cambi√°ndolo si lo deseamos. Por lo que en un momento puede ser de tipo string y despu√©s de tipo boolean:

## Tipado en JavaScript

Para proyectos de sofware que tienen una gran escalabilidad, esto podr√≠a ser fuente de fallas en el programa.

Controlando la flexibilidad
Gracias a TypeScript podemos manejar el tipado de las variables para evitar anomal√≠as en el c√≥digo.

En JavaScript, para declarar una variable constante lo realizamos as√≠:

const productPrice = 12;
En TypeScript, para el caso anterior, es similar solo que a√±adimos : y el tipo de dato de la variable, la cual ser√≠a number. A esto √∫ltimo se le llama type annotation o anotaci√≥n de tipo:

const productPrice: number = 12;

## Tipos inferidos

TypeScript puede inferir el tipo de dato de una variable a pesar de no haberlo declarado expl√≠citamente.

Inferencia de tipos
A partir de la inicializaci√≥n de la variable TypeScript infiere el tipo que ser√° a lo largo del c√≥digo y este no puede variar. Por ejemplo:

- let myName = "Victoria";

Si bien no indicamos el tipo de dato como se har√≠a de esta manera:

- let myName: string = "Victoria";

TypeScript infiere que la variable myName ser√° del tipo string y en adelante no podr√° tomar un valor que no sea de este tipo de dato.

- myName = 30;

//Nos se√±alar√° como error pues se le quiere asignar un n√∫mero a una variable de tipo string.
En Visual Studio Code puedes obtener autocompletado teniendo sugerencias seg√∫n el tipo de dato que sea la variable:
Autocompletado en Visual Studio Code

- Nombres de variables iguales

TypeScript te indicar√° como error aquellas variables con el mismo nombre a pesar de estar en archivos distintos. Esto no suceder√° en entornos preconfigurados como por ejemplo Angular o React, ya que estos trabajan de forma modular o tienen un alcance (scope) para cada variable.

Si deseas trabajar con los mismos nombres de variables en diferentes archivos, puedes crear una funci√≥n an√≥nima autoejecutada:

    * ( () => {
        let myName = "Victoria";
        })();
Lo mismo por cada variable que desees tener el mismo nombre (myName para este ejemplo) deber√°s crear este tipo de funci√≥n para evitar que te den estas advertencias.

## Operaciones

En JavaScript, una variable de tipo number puede f√°cilmente ser concatenado con otra de tipo string:

    * //JavaScript
    let myNumber = 30;
    myNumber = myNumber + "5"; //El resultado ser√≠a '305'

Sin embargo, esto podr√≠a llevar confusiones y errores durante la ejecuci√≥n del programa, adem√°s de estar cambiando el
tipo de dato de la variable. Por ello, en TypeScript solo se pueden hacer operaciones num√©ricas entre n√∫meros valga
la redundancia:

    * //TypeScript
    let myNumber: number = 30;

    myNumber = myNumber + 10; //CORRECTO
    myNumber = myNumber + "10"; //INCORRECTO

## Uso de variables sin inicializar

Ser√°n se√±alados como errores aquellas variables que queramos usar sin haberles dado un valor inicial:

    *//TypeScript
    let productInStock: number;
    console.log("Product in stock: " + productInStock);

Se√±alar que si no se va a inicializar a√∫n la variable, definir expl√≠citamente el tipo de dato, pues TypeScript no puede inferirlo si no tiene un valor inicial.

## Conversi√≥n de n√∫meros de tipo string a tipo number

Para esto usaremos el m√©todo parseInt:

    * let discount: number = parseInt("123");

    let numeroString: string = "100";
    let nuevoNumero: number;
    nuevoNumero = parseInt(numeroString);

Esto funciona si el string tiene solo y exclusivamente n√∫meros que no empiecen con 0. De lo contrario, el resultado ser√°
de tipo NaN (Not a Number):

    * //TypeScript
    let numeroPrueba: number = parseInt("palabra");
    console.log(numeroPrueba); //NaN

## Binarios y Hexadecimales

TypeScript nos puede indicar error si intentamos definir n√∫meros binarios que tengan n√∫meros que no sean 0 o 1 y si
declaramos hexadecimales usando valores fuera del rango:

    * //**********TypeScript**********
    //Binarios: se definen colocando "0b" al inicio del valor
    let primerBinario = 0b1010; //CORRECTO
    let segundobinario = 0b1210; //INCORRECTO. El 2 es inv√°lido

    //Hexadecimales: se definen colocando "0x" al inicio del valor
    let primerHexa = 0xfff; //CORRECTO
    let segundoHexa = 0xffz; //INCORRECTO. El "z" es inv√°lido

En consola, si est√°n correctamente asignados, se har√° una conversi√≥n a decimal de dichos n√∫meros:

    let primerHexa = 0xfff;
    console.log(primerHexa); // 4095

    let primerBinario = 0b1010;
    console.log(primerBinario); // 10

## Consejo

Cuando definas una variable de tipo de dato number, es preferible que el nombre de tipo sea en min√∫scula. Esto como buena pr√°ctica, pues se har√° referencia al tipo de dato number y no al objeto Number propio del lenguaje:

    let myNumber: number = 20; // Buena practica.
      let otherNumber: Number = 20; // Mala practica.

## Boolens

Este tipo de dato puede tomar dos valores: true o false.

    let isEnable: boolean = true;
    let isNew = false;

## String

Este tipo de dato nos permite almacenar una cadena de caracteres.

Podemos definir un string con:

- Comillas simples:
  let myProduct = 'Soda'; //CORRECTO
  let comillasDobles = 'Puedo "usar" comillas dobles tambien'; //CORRECTO
  let comillaInvalida = 'No puedo 'usar' otra vez una comilla simple'; //INCORRECTO

Se pueden usar comillas dobles dentro, m√°s no otra vez comillas simples.

- Comillas dobles:
  let myProduct = "Soda"; //CORRECTO
  let comillaSimple = "Puedo 'usar' comilla simple tambien"; //CORRECTO
  let comillaInvalida = "No puedo "usar" otra vez las comillas dobles"; //INCORRECTO

Se puede usar comillas simples dentro, m√°s no otra vez comillas dobles.

- Usando backticks:
  let myName = `Frank`;

Esta forma de asignar string trae algunas ventajas:

- Declarar valores de m√∫ltiples l√≠neas:
  let texto = `Nunca pares de aprender :)`;
- Concatenar dentro del mismo string. Para esto es necesario usar este s√≠mbolo del d√≥lar seguido de llaves ${} y escribir lo que queremos concatenar dentro de esas llaves:
  let variableTitulo = "TypeScript";
  let summary = `title: ${variableTitulo}`;
- Tambi√©n respeta la indentaci√≥n:
  let html= `

  <!DOCTYPE html>

  <html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Document</title>
    </head>
    <body>
        ...
    </body>
    </html>
    `;

## Array

Es una colecci√≥n de datos ordenada. Los definimos de la siguiente manera:

    let prices = [1,2,3,4,5];

    /* M√©todo Push para agregar un elemento al final del array */
    prices.push(6);
    console.log(prices); // [1,2,3,4,5,6]

Para el array prices, TypeScript, de no indicarle expl√≠citamente, va a inferir que este solo contendr√° valores del tipo number, por lo que si se quiere agregar un valor string, por ejemplo, nos indicar√° un error:

    //TypeScript
    prices.push("texto"); //ERROR. Se espera agregar solo n√∫meros al array.

Esto debido a que en su inicializaci√≥n se le asign√≥ un array que solo conten√≠a n√∫meros.

Tambi√©n nos indicar√° error si pretendemos hacer operaciones exclusivas de un tipo de dato sobre la de otro tipo:

    let meses = ["Mayo","Junio","Julio"];
    meses.map( item => item * 2 ); //ERROR. Se pretende realizar una multiplicaci√≥n usando strings.
Tipado de arrays en TypeScript

Lo puedes definir as√≠:

- Indicar expl√≠citamente los tipos de datos que almacenar√° el array:

  let prices: (number | string)[] = ["hola",2,4,6,"mundo"];
  let otherPrices: (boolean | number)[];

Para este caso, a menos que la variable sea una constante, no es necesario que inicialices la variable, pues ya le indicaste el tipo de dato.

En la inicializaci√≥n de la variable, colocar datos con el tipo de dato que quieres que soporte tu array en adelante para que lo pueda inferir TypeScript:

    //TypeScript
    let prices = ["hola",2,4,6,"mundo"];
    // "hola", "mundo" => string
    // 2,4,6 => number

# Manipulaci√≥n de Arrays en JavaScript.

Requisitos iniciales
Como requisito inicial, deber√°s tener dos carpetas: client y server que servir√°n para ejercicios en el navegador y en el servidor, respectivamente.
Tambi√©n necesitar√°s instalar una dependencia llamada http-server. Asimismo puedes clonar el [repositorio Git](https://github.com/platzi/curso-manipulacion-de-arrays/tree/main)  de GitHub del curso.

Estructura inicial del proyecto del curso
Si no conoces c√≥mo iniciar un proyector para instalar dependencias, te recomiendo que realices el curso de [Gesti√≥n de Dependencias y Paquetes con NPM](https://platzi.com/cursos/npm/).

Te recomiendo usar Codi.link, es un editor de c√≥digo para escribir HTML, CSS y JavaScript y visualizar el resultado a tiempo real. Da√±a el c√≥digo, resuelve los problemas de cada clase o genera nuevos ejemplos que te ayuden a reforzar los temas aprendidos.

## For Each

El m√©todo forEach de los arrays consiste en ejecutar una funci√≥n (callback) para cada uno de los elementos iterados. Iterar significa repetir una acci√≥n 
varias veces.

Este m√©todo recibe dos argumentos:

- La funci√≥n que itera cada elemento del array (obligatorio).
- Un objeto al que puede hacer referencia el contexto this en la funci√≥n. Si se lo omite, ser√° undefined. Recuerde que this en arrow functions es el objeto global.

        array.forEach(function(), thisArg)

La funci√≥n, que recibe como argumento el m√©todo forEach, utiliza tres par√°metros opcionales:

- El valor actual del elemento iterado. Es decir, si es la primera iteraci√≥n, ser√° el primer elemento, y as√≠ sucesivamente.
- El √≠ndice del elemento iterado. Es decir, si es la primera iteraci√≥n, ser√° el √≠ndice 0, y as√≠ sucesivamente.
- El array que est√° iterando.
        array.forEach(function(element, index, array))

## Diferencia entre la estructura for y el m√©todo forEach
Los m√©todos de arrays nos permiten realizar algoritmos con una menor cantidad de l√≠neas que una estructura for, con un resultado igual o parecido.

        const letters=['a','b','c']

        // Utilizando la estructura repetitiva for
        for(let index=0; index<letters.length; index++){
            const element=letters[index]
            console.log('for',element)
        }

    // Utilizando el m√©todo forEach
    letters.forEach(item => console.log('forEach',item))
## Mostrar elementos de un array al usuario
Ahora que ya conoces c√≥mo funciona el m√©todo forEach, util√≠zalo para agregar elementos al HTML y as√≠ que el usuario lo mire.

Por ejemplo, en un archivo HTML agrega una etiqueta div con un id app, que nos servir√° para agregar nuestros elementos.

        <div id="app"></div>
Despu√©s crea la l√≥gica en un archivo de JavaScript.

        const products = [
        { title: 'Burger', price: 121 },
        { title: 'Pizza', price: 20 },
        { title: 'Soda', price: 5 },
        ]

        const app = document.getElementById('app')

        products.forEach(product => {
        app.innerHTML += `<li>${product.title} -$ ${product.price}</li>`
        })
Y listo, en pantalla aparecer√°n los elementos del array products con su t√≠tulo y precio. Revisa el resultado en este codi.link.

## Ejercicio utilizando la funci√≥n forEach
Crea una lista de tareas, a partir de un array que contenga el t√≠tulo y el estado (completado o no) y mu√©stralos en un archivo HTML. 
Puedes utilizar un input de tipo checkbox para indicar el estado de la tarea. ¬°Comparte tu trabajo en la secci√≥n de aportes!

## Mutable o Inmutable

Los conceptos de mutabilidad e inmutabilidad son muy importantes para los siguientes m√©todos de arrays. Existen m√©todos mutables que cambian el array original; e inmutables que devuelven un 
array diferente al original.

## Referencias en memoria
En JavaScript, cada estructura est√° guardada en una referencia en memoria, por lo que si cambiamos un elemento en el array, tambi√©n lo haremos en esa referencia. Al clonar arrays, se crea un nuevo array que tiene las mismas referencias en memoria que el original, por lo que si se realiza un cambio en el original, tambi√©n cambiar√° en la copia.

        const original = [1,2,3]
        const copia = original
        copia[0] = "Hola"

        console.log(original) // [ 'Hola', 2, 3 ]
## Diferencia entre mutabilidad e inmutabilidad
Con lo mencionado anteriormente, mutable es aquella acci√≥n que cambia el valor en la referencia en memoria del elemento del array original, 
provocando que cambien el original y la copia. Inmutable es la acci√≥n en la que se cambia el valor, pero en una referencia diferente del original, 
provocando que el original siga igual.

La mutabilidad es m√°s flexible y una buena opci√≥n si se requiere cambiar, actualizar o eliminar datos; pero esto puede ocasionar fallos o resultados 
err√≥neos en nuestra aplicaci√≥n. La inmutabilidad es m√°s exigente, te permite generar nuevas estructuras para manejarlas sin cambiar la original; pero 
esto puede provocar que la memoria colapse.

Por lo que, ¬øcu√°l es mejor? La respuesta es ninguna, cada uno te permite manejar estructuras de datos, por ende es necesario identificar cu√°l forma 
es la adecuada a aplicar en un algoritmo.

## Qu√© es el m√©todo map

El m√©todo map consiste en crear un nuevo array a partir de los elementos originales transformados mediante una funci√≥n (callback) y es inmutable.

La transformaci√≥n implica cambiar cualquier elemento en otro, ya sea un n√∫mero, un objeto, otro array. Las posibilidades son infinitas.

Este m√©todo recibe dos argumentos:

- La funci√≥n que itera y transforma cada elemento del array (obligatorio).
- Un objeto al que puede hacer referencia el contexto this en la funci√≥n. Si se lo omite, ser√° undefined. Recuerde que this en arrow functions es el objeto global.

        let otherArray = array.map(function(), thisArg)

La funci√≥n, que recibe como argumento el m√©todo map, utiliza tres par√°metros:

- El valor actual del elemento iterado. Es decir, si es la primera iteraci√≥n, ser√° el primer elemento, y as√≠ sucesivamente.
- El √≠ndice del elemento iterado. Es decir, si es la primera iteraci√≥n, ser√° el √≠ndice 0, y as√≠ sucesivamente.
- El array que est√° iterando.

        const other = array.map(function(element, index, array))

Diferencia entre la estructura for y el m√©todo map
Los m√©todos de arrays nos permiten realizar algoritmos con una menor cantidad de l√≠neas que una estructura for, con un resultado igual o parecido.

Por ejemplo, hagamos un algoritmo que transforme cada elemento de un array en el doble de s√≠ mismo.

Si utilizamos la estructura For, necesitaremos un array adicional vac√≠o y utilizarlo con el m√©todo push para agregar los elementos transformados. El m√©todo push es mutable.

        const numbers = [1,2,3,4,5]
        const newNumbers = []

        for(let i=0; i< numbers.length; i++){
            const number = numbers[i]
            newNumbers.push(number*2)
        }

        console.log(newNumbers) // [ 2, 4, 6, 8, 10 ]

Con el m√©todo map, solo debemos establecer la funci√≥n que indique la transformaci√≥n para cada elemento.

        const numbers = [1,2,3,4,5]
        const newNumbers = numbers.map( function(number){
            return number * 2
        })
        // o 
        const newNumbers = numbers.map(number => number * 2)

        console.log(newNumbers) // [ 2, 4, 6, 8, 10 ]

Recuerda siempre retornar un valor en la funci√≥n callback del m√©todo.

## Diferencia entre forEach y map

La principal diferencia entre estos dos es que forEach solamente itera cada elemento, mientras que map itera y transforma cada elemento en un nuevo array.

¬øPero tambi√©n se pueden transformar los elementos con forEach? S√≠, sin embargo, necesitas agregar cada elemento en cada iteraci√≥n a un array nuevo, caso contrario puedes mutar el array original.

# Lecturas recomendadas

[Array - JavaScript | MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/)

## Map Reloaded

Ahora que ya sabes c√≥mo funciona el m√©todo map de arrays estudiemos diferentes situaciones que deber√°s manejar array de objetos como los siguientes datos de orders.

    const orders = [
    {
        customerName: "Nicolas",
        total: 60,
        delivered: true,
    },
    {
        customerName: "Zulema",
        total: 120,
        delivered: false,
    },
    {
        customerName: "Santiago",
        total: 180,
        delivered: true,
    },
    {
        customerName: "Valentina",
        total: 240,
        delivered: true,
    },
    ]

## Extrayendo datos necesarios

De un conjunto de datos a veces necesitas ciertos atributos para realizar una operaci√≥n, extraer los nombres o cuantificar un suceso. El m√©todo map te permite extraer estos datos seg√∫n los puedas utilizar.

        const totales = orders.map(order => order.total)

        console.log(totales) // [ 60, 120, 180, 240 ]
## Transformando objetos dentro de un array

De un conjunto de datos, de los cuales son objetos, a veces requieres a√±adir una propiedad nueva o eliminar una que no es necesaria. Si necesitas transformar objetos dentro de un array, debes tener en cuenta que cada objeto tiene una referencia en memoria propia. Por lo que si transformas un objeto, tambi√©n lo har√°s en el original como en el nuevo, aun cuando el m√©todo map es inmutable.

Los par√°metros por referencia los debes tener presente cuando manejes objetos y arrays.

    // Ejemplo donde transformas los objetos originales
    const tarifas = orders.map(order => {
        order.tax = 0.19
        return order
    })

    tarifas[0] === orders[0] // true
    tarifas[1] === orders[1] // true
Una forma de evitar este comportamiento, es crear un nuevo objeto con el spread operator (operador de propagaci√≥n).

    // Ejemplo donde no transformas los objetos originales
    const tarifas = orders.map(order => {
        return {
            ...order,
            item: 0.19,
        }
    })

    tarifas[0] === orders[0] // false
    tarifas[1] === orders[1] // false
Contribuci√≥n creada por: Andr√©s Guano.


